{
    "Đơn đồ thị vô hướng": "Đơn đồ thị vô hướng G=<V,E> bao gồm V là tập các đỉnh, E là tập các cặp không có thứ tự gồm hai phần tử khác nhau của V gọi là các cạnh.",
    "Đa đồ thị vô hướng": "Đa đồ thị vô hướng G=<V,E> bao gồm V là tập các đỉnh, E là họ các cặp không có thứ tự gồm hai phần tử khác nhau của V gọi là tập các cạnh. e1 ∈ E, e2 ∈ E được gọi là cạnh bội nếu chúng cùng tương ứng với một cặp đỉnh.",
    "Giả đồ thị vô hướng": "Giả đồ thị vô hướng G=<V,E> bao gồm V là tập đỉnh, E là họ các cặp không có thứ tự gồm hai phần tử (hai phần tử không nhất thiết phải khác nhau) trong V được gọi là các cạnh. Cạnh e được gọi là khuyên nếu có dạng e = (u,u).",
    "Đơn đồ thị có hướng": "Đơn đồ thị có hướng G=<V,E> bao gồm V là tập các đỉnh, E là tập các cặp có thứ tự gồm hai phần tử của V gọi là các cung.",
    "Đa đồ thị có hướng": "Đa đồ thị có hướng G=<V,E> bao gồm V là tập đỉnh, E là họ các cặp có thứ tự gồm hai phần tử khác nhau của V được gọi là các cung. Hai cung e1, e2 tương ứng với cùng một cặp đỉnh được gọi là cung lặp.",
    "hai đỉnh kề nhau": "Hai đỉnh 𝑢 và 𝑣 của đồ thị vô hướng 𝐺 = <𝑉,𝐸 > được gọi là kề nhau nếu (𝑢,𝑣)là cạnh thuộc đồ thị 𝐺. Nếu 𝑒 = (𝑢,𝑣)là cạnh của đồ thị 𝐺 thì ta nói cạnh này liên thuộc với hai đỉnh 𝑢 và 𝑣.",
    "tổng bậc của đỉnh": "Giả sử 𝐺 =< 𝑉,𝐸 > là đồ thị vô hướng với 𝑚 cạnh, khi đó: Tổng deg𝑣 = 2𝑚.",
    "Đường đi đồ thị": "Đường đi độ dài 𝑛 từ đỉnh 𝑢 đến đỉnh 𝑣 trên đồ thị vô hướng 𝐺 =< 𝑉,𝐸 >là dãy x0, 𝑥1,.. . , 𝑥𝑛−1,𝑥𝑛, trong đó 𝑛 là số nguyên dương, 𝑥0 = 𝑢, 𝑥𝑛 = 𝑣,(𝑥𝑖,𝑥𝑖+1) ∈ 𝐸, 𝑖 = 0,1,2,...,𝑛 − 1.",
    "Chu trình đồ thị": "Chu trình là một đường đi có đỉnh đầu trùng với đỉnh cuối (𝑢 = 𝑣).",
    "đồ thị vô hướng liên thông": "Đồ thị vô hướng được gọi là liên thông nếu luôn tìm được đường đi giữa hai đỉnh bất kỳ của nó.",
    "Cạnh cầu": "Cạnh 𝑒 ∈ 𝐸 được gọi là cầu nếu loại bỏ e làm tăng thành phần liên thông của đồ thị.",
    "Đỉnh trụ": "Đỉnh 𝑢 ∈ 𝑉 được gọi là đỉnh trụ nếu loại bỏ 𝑢 cùng với các cạnh nối với 𝑢 làm tăng thành phần liên thông của đồ thị.",
    "hai đỉnh kề nhau ": "Nếu 𝑒 =(𝑢,𝑣) là cung của đồ thị có hướng 𝐺 thì ta nói hai đỉnh 𝑢 và 𝑣 là kề nhau, và nói cung (𝑢,𝑣) nối đỉnh 𝑢 với đỉnh 𝑣, hoặc nói cung này đi ra khỏi đỉnh 𝑢 và đi vào đỉnh 𝑣.",
    "Bán bậc ra": "Số cung của đồ thị đi ra khỏi 𝑣 và ký hiệu là 𝑑𝑒𝑔+(𝑣).",
    "Bán bậc vào": "Là số cung của đồ thị đi vào 𝑣 và ký hiệu là 𝑑𝑒𝑔−(𝑣).",
    "liên thông mạnh": "Đồ thị có hướng được gọi là liên thông mạnh nếu giữa hai đỉnh bất kỳ 𝑢 ∈ 𝑉,𝑣 ∈ 𝑉 đều có đường đi từ 𝑢 đến 𝑣.",
    "liên thông yếu": "Đồ thị có hướng được gọi là liên thông yếu nếu đồ thị vô hướng tương ứng với nó là liên thông.",
    "định chiều được ": "Là đồ thị có thể biến đổi các cạnh thành các cung để nhận được một đồ thị có hướng liên thông mạnh.",
    "Đồ thị đầy đủ ": "Là đơn đồ thị vô hướng 𝑛 đỉnh, ký hiệu là 𝐾𝑛, mà giữa hai đỉnh bất kỳ của nó đều có cạnh nối.",
    "Đồ thị vòng": "Là đơn đồ thị vô hướng 𝑛 đỉnh, ký hiệu là 𝐶𝑛 (𝑛 ≥ 3) gồm các cạnh (1,2),(2,3),…,(𝑛 − 1,𝑛),(𝑛,1).",
    "Đồ thị bánh xe": "Là đồ thị 𝑛 đỉnh, ký hiệu là 𝑊𝑛, thu được bằng cách bổ sung một đỉnh nối với tất cả các đỉnh của đồ thị vòng 𝐶𝑛−1.",
    "Đồ thị hai phía": "Là đồ thị có tập đỉnh 𝑉 có thể phân hoạch thành hai tập 𝑋 và 𝑌 sao cho mỗi cạnh chỉ nối một đỉnh từ X và một đỉnh từ Y.",
    "Biểu diễn ma trận kề ": "Là ma trận 𝑛 × 𝑛, 𝐴={𝑎𝑖𝑗:𝑎𝑖𝑗 = 1 𝑛ế𝑢 (𝑖,𝑗) ∈ 𝐸, 𝑎𝑖𝑗 = 0 𝑛ế𝑢 (𝑖,𝑗) ∉ 𝐸; 𝑖,𝑗 = 1, 2,. . . , 𝑛}.",
    "Biểu diễn ma trận trọng số": "Mỗi cạnh 𝑒 = (𝑢,𝑣) được gán một trọng số 𝑐(𝑢,𝑣). Ma trận trọng số 𝑐 = 𝑐[𝑖,𝑗], 𝑐[𝑖,𝑗] = 𝑐(𝑖,𝑗) nếu (𝑖,𝑗) ∈ 𝐸, và 𝑐[𝑖, 𝑗] = 𝜃 (0,∞,−∞) nếu (𝑖,𝑗) ∉ 𝐸.",
    "Biểu diễn ma trận liên thuộc vô hướng": "Là ma trận kích thước 𝑛 ×𝑚. a𝑖𝑗 = 1, nế𝑢 đỉ𝑛ℎ 𝑖 𝑙𝑖ê𝑛 𝑡ℎ𝑢ộ𝑐 𝑣ớ𝑖 𝑐ạ𝑛ℎ 𝑗; 0, 𝑛ế𝑢 đỉ𝑛ℎ 𝑖 𝑘ℎô𝑛𝑔 𝑙𝑖ê𝑛 𝑡ℎ𝑢ộ𝑐 𝑣ớ𝑖 𝑐ạ𝑛ℎ 𝑗.",
    "Biểu diễn ma trận liên thuộc có hướng": "Là ma trận kích thước 𝑛 ×𝑚. a𝑖𝑗 = 1, 𝑛ế𝑢 𝑖 𝑙à đỉ𝑛ℎ đầ𝑢 𝑐ủ𝑎 𝑐𝑢𝑛𝑔 𝑒𝑗; −1,𝑛ế𝑢 𝑖 𝑙à đỉ𝑛ℎ 𝑐𝑢ố𝑖 𝑐ủ𝑎 𝑐𝑢𝑛𝑔 𝑒𝑗; 0, 𝑛ế𝑢 𝑖 𝑘ℎô𝑛𝑔 𝑙à đầ𝑢 𝑚ú𝑡.",
    "Ưu và nhược điểm của danh sách kề": "Ưu điểm: Dễ dàng duyệt đỉnh kề, tối ưu biểu diễn. Nhược điểm: Khó khăn cho người đọc có kỹ năng lập trình yếu.",
    "Ưu và nhược điểm của danh sách cạnh": "Ưu điểm: Tiết kiệm bộ nhớ với đồ thị thưa (𝑚 < 6𝑛), thuận lợi cho một số thuật toán. Nhược điểm: Duyệt đỉnh kề tốn chi phí tính toán cao (phải duyệt tất cả các cạnh).",
    "Thuật toán DFS": "DFS(u):\n  Bước 1: Khởi tạo\n    stack = ∅, push(stack, u), <Thăm u>, chuaXet[u] = false\n  Bước 2: Lặp\n    while stack ≠ ∅:\n      s = pop(stack)\n      for t ∈ Ke(s):\n        if chuaXet[t]:\n          <Thăm t>, chuaXet[t] = false, push(stack, s), push(stack, t), break",
    "Độ phức tạp của DFS": "Biểu diễn đồ thị bằng:\n- Ma trận kề: O(n^2)\n- Danh sách cạnh: O(n * m)\n- Danh sách kề: O(max(n, m))",
    "Thuật toán BFS": "BFS(u):\n  Bước 1: Khởi tạo\n    queue = ∅, push(queue, u), chuaXet[u] = false\n  Bước 2: Lặp\n    while queue ≠ ∅:\n      s = pop(queue), <Thăm s>\n      for t ∈ Ke(s):\n        if chuaXet[t]:\n          push(queue, t), chuaXet[t] = false",
    "Độ phức tạp của BFS ": "Biểu diễn đồ thị bằng:\n- Ma trận kề: O(n^2)\n- Danh sách cạnh: O(n.m)\n- Danh sách kề: O(max(n, m))",
    "Cách duyệt các thành phần liên thông của đồ thị": "Duyet-TPLT() {\n  Bước 1: Khởi tạo: soTPLT = 0\n  Bước 2: Lặp\n    for u ∈ V:\n      if chuaXet[u]:\n        soTPLT = soTPLT + 1, BFS(u) (hoặc DFS(u)), <Ghi nhận TPLT>\n  Bước 3: Trả lại kết quả: return <các TPLT>\n }",
    "kiểm tra tính liên thông mạnh": "Strong_Connected(G = <V, E>) {\n  Bước 1: Khởi tạo: ReInit() (tất cả là true)\n  Bước 2: Lặp\n    for u ∈ V:\n      if BFS(u) ≠ V (hoặc DFS(u)) return false\n      else ReInit()\n  Bước 3: Trả lại kết quả: return true\n }",
    "tìm các đỉnh trụ đồ thị": "Duyet_Tru(G = <V, E>) {\n  Bước 1: Khởi tạo: ReInit()\n  Bước 2: Lặp\n    for u ∈ V: // lấy mỗi đỉnh u\n      chuaXet[u] = false // cấm BFS/DFS duyệt u\n      if (BFS(v) ≠ V \\ {u}) // v là đỉnh bất kỳ khác u\n        <Ghi nhận u là đỉnh trụ>\n      ReInit() // khởi tạo lại mảng chuaXet[]\n }",
    "tìm các cạnh cầu  đồ thị": "Duyet_Cau(G = <V, E>) {\n  Bước 1: Khởi tạo: ReInit()\n  Bước 2: Lặp\n    for e ∈ E: // lấy mỗi cạnh e\n      E = E \\ {e} // loại bỏ cạnh e\n      if (BFS(1) ≠ V) // kiểm tra từ đỉnh 1 (hoặc đỉnh bất kỳ)\n        <Ghi nhận e là cạnh cầu>\n      E = E ∪ {e} // hoàn trả cạnh e\n      ReInit()\n }",
    "Chu trình Euler": "Chu trình đơn trong đồ thị G đi qua tất cả các cạnh của nó được gọi là chu trình Euler.",
    "Đường đi Euler": "Đường đi đơn trong đồ thị G đi qua tất cả các cạnh của nó được gọi là đường đi Euler.",
    "Đồ thị Euler": "Đồ thị được gọi là đồ thị Euler nếu nó có chu trình Euler.",
    "Đồ thị nửa Euler": "Đồ thị được gọi là đồ thị nửa Euler nếu nó có đường đi Euler.",
    "chứng minh đồ thị Euler?": "Vô hướng: Liên thông và mọi đỉnh bậc chẵn.\nCó hướng: Liên thông yếu và mọi đỉnh có bán bậc ra = bán bậc vào.",
    "chứng minh  đồ thị  Euler?": "Vô hướng:\n 1. Kiểm tra liên thông (dùng DFS/BFS).\n 2. Kiểm tra bậc tất cả các đỉnh là chẵn.\nCó hướng:\n 1. Kiểm tra liên thông yếu.\n 2. Kiểm tra 𝑑𝑒𝑔+(𝑣) = 𝑑𝑒𝑔−(𝑣) với mọi đỉnh v.",
    "Thuật toán tìm chu trình Euler ": "Euler-Cycle(𝑢){\n  // Bước 1: Khởi tạo\n  𝑠𝑡𝑎𝑐𝑘 = ∅; 𝐶𝐸 = ∅; p𝑢𝑠ℎ(𝑠𝑡𝑎𝑐𝑘, 𝑢);\n  // Bước 2: Lặp\n  while(𝑠𝑡𝑎𝑐𝑘 ≠ ∅){\n    𝑠 = 𝒈𝒆𝒕(𝑠𝑡𝑎𝑐𝑘);\n    if(𝐾𝑒(𝑠) ≠ ∅){\n      𝑡 = <đỉnh đầu tiên trong 𝐾𝑒(𝑠)>;\n      p𝑢𝑠ℎ(𝑠𝑡𝑎𝑐𝑘, 𝑡); 𝐸 = 𝐸\\{(𝑠, 𝑡)};\n    }\n    else{\n      𝑠 = p𝑜𝑝(𝑠𝑡𝑎𝑐𝑘); 𝑠 ⇒ 𝐶𝐸;\n    }\n  }\n  // Bước 3: Trả lại kết quả: <lật ngược 𝐶𝐸>;\n }",
    "Điều kiện là đồ thị nửa Euler?": "Vô hướng: Liên thông và có 0 hoặc 2 đỉnh bậc lẻ.\nCó hướng: Liên thông yếu VÀ (tồn tại đúng 2 đỉnh 𝑢, 𝑣 sao cho 𝑑𝑒𝑔+(𝑢)−𝑑𝑒𝑔−(𝑢) = 1 và 𝑑𝑒𝑔−(𝑣)−𝑑𝑒𝑔+(𝑣) = 1) VÀ (các đỉnh còn lại có 𝑑𝑒𝑔+ = 𝑑𝑒𝑔−).",
    "chứng minh đồ thị là nửa Euler?": "Vô hướng:\n 1. Kiểm tra liên thông.\n 2. Đếm số đỉnh bậc lẻ (phải là 0 hoặc 2).\nCó hướng:\n 1. Kiểm tra liên thông yếu.\n 2. Kiểm tra các điều kiện về bán bậc (phải có đúng 2 đỉnh đặc biệt).",
    "tìm đường đi Euler": "Tương tự thuật toán tìm chu trình Euler, chỉ khác đỉnh bắt đầu 𝑢:\n- Vô hướng: 𝑢 là đỉnh bậc lẻ (nếu có).\n- Có hướng: 𝑢 là đỉnh thỏa mãn 𝑑𝑒𝑔+(𝑢)−𝑑𝑒𝑔−(𝑢) = 1.",
    "Đường đi Hamilton ": "Đường đi qua tất cả các đỉnh của đồ thị, mỗi đỉnh đúng một lần.",
    "Chu trình Hamilton ": "Chu trình bắt đầu tại 𝑣, qua tất cả các đỉnh còn lại mỗi đỉnh đúng một lần, rồi quay lại 𝑣.",
    "Đồ thị Hamilton": "Đồ thị được gọi là đồ thị Hamilton nếu có chu trình Hamilton.",
    "Đồ thị nửa Hamilton ": "Đồ thị được gọi là đồ thị nửa Hamilton nếu có đường đi Hamilton.",
    "Cây": "Cây là một đồ thị vô hướng, liên thông, không có chu trình.",
    "Rừng": "Rừng là một đồ thị vô hướng, không có chu trình (mỗi thành phần liên thông của nó là một cây).",
    "Các tính chất Cây?": "Giả sử 𝑇 là đồ thị 𝑛 đỉnh, các khẳng định sau là tương đương:\n 1) 𝑇 là một cây.\n 2) 𝑇 không có chu trình và có 𝑛 − 1 cạnh.\n 3) 𝑇 liên thông và có đúng 𝑛 − 1 cạnh.\n 4) 𝑇 liên thông và mỗi cạnh của nó đều là cầu.\n 5) Giữa hai đỉnh bất kỳ của 𝑇 có đúng một đường đi đơn.\n 6) 𝑇 không chứa chu trình nhưng thêm một cạnh bất kỳ sẽ tạo ra đúng một chu trình.",
    "Cây khung": "Cho 𝐺 là đồ thị vô hướng liên thông. Đồ thị con 𝑇 của 𝐺 là một cây khung nếu 𝑇 là một cây và tập đỉnh của 𝑇 bằng tập đỉnh của 𝐺.",
    "xây dựng Cây khung ": "Cách xây dựng: Sử dụng thuật toán duyệt DFS hoặc BFS. Mỗi khi ta đến được đỉnh 𝑣 (chưa xét) từ đỉnh 𝑢, cạnh (𝑢, 𝑣) được kết nạp vào cây khung.\n\n## Thuật toán (DFS đệ quy)\nTree-DFS(𝑢){\n  cℎ𝑢𝑎𝑥𝑒𝑡[𝑢] = 𝑓𝑎𝑙𝑠𝒆;\n  for(𝑣 ∈ 𝐾𝑒(𝑢)){\n    if(𝑐ℎ𝑢𝑎𝑥𝑒𝑡[𝑣]){\n      𝑇 = 𝑇 ∪ { 𝑢, 𝑣 }; Tree-DFS(𝑣);\n    }\n  }\n}",
    "Kruskal": "Kruskal(){\n //B1: T = ∅; 𝑑(H) = 0;\n //B2: <sắp xếp các cạnh theo trọng số tăng dần>;\n //B3: Lặp\n  while(|𝑇| < 𝑛 − 1 && 𝐸 ≠ ∅ ){\n    𝑒 = <Cạnh nhỏ nhất>; 𝐸 = 𝐸\\{𝑒};\n    if (𝑇 ∪ {𝑒} không tạo chu trình ){\n      T = 𝑇 ∪ {𝑒}; 𝑑(H) = 𝑑(H) + 𝑑(𝑒);\n    }\n  }\n //B4: Trả về (T, d(H)) hoặc báo lỗi không liên thông.\n}",
    "Prim": "Prim(s){\n //B1: 𝑉𝐻 = {𝑠}; 𝑉 = 𝑉\\{𝑠}; 𝑇 = ∅; 𝑑(H) = 0;\n //B2: Lặp\n  while(V ≠ ∅ ){\n    𝑒 = (𝑢, 𝑣); //Cạnh nhỏ nhất với 𝑢 ∈ 𝑉, v ∈ 𝑉𝐻\n    if(𝑘ℎô𝑛𝑔 𝑡ì𝑚 đượ𝑐 𝑒) return <Không liên thông>;\n    T = 𝑇 ∪ {𝑒}; 𝑑(H) = 𝑑(H) + 𝑑(𝑒);\n    𝑉𝐻 = 𝑉𝐻 ∪ {𝑢}; V = V\\{𝑢};\n  }\n //B3: Trả về (T, d(H));\n}",
    "Độ dài đường đi trong đồ thị có trọng số": "Xét đồ thị G = <V, E> có trọng số a(u, v). Độ dài của đường đi v0, v1, ..., vk là tổng trọng số các cạnh: Σ (i = 1 → k) a(vi-1, vi).",
    "đường đi ngắn nhất từ một đỉnh cố định": "Tìm đường đi ngắn nhất từ s đến tất cả các đỉnh còn lại.\n- Trọng số không âm: dùng thuật toán Dijkstra.\n- Có trọng số âm (không chu trình âm): dùng Bellman-Ford.",
    "đường đi ngắn nhất giữa cặp đỉnh": "Tìm đường đi ngắn nhất giữa mọi cặp đỉnh.\n- Trọng số không âm: chạy Dijkstra n lần.\n- Không có chu trình âm: dùng thuật toán Floyd-Warshall.",
    "Dijkstra": "Dùng cho bài toán tìm đường đi ngắn nhất từ một đỉnh cố định (s) khi trọng số không âm.\nDijkstra(s) {\n Bước 1 (Khởi tạo): d[s] = 0; T = V \\ {s}; for v ∈ V: d[v] = a(s, v), truoc[v] = s\n Bước 2 (Lặp):\n  while T ≠ ∅:\n    chọn u ∈ T sao cho d[u] = min{ d[z] | z ∈ T }\n    T = T \\ {u}\n    for v ∈ T:\n      if d[v] > d[u] + a(u, v):\n        d[v] = d[u] + a(u, v), truoc[v] = u\n }",
    "Bellman-Ford": "Dùng cho bài toán tìm đường đi ngắn nhất từ một đỉnh cố định (s) khi đồ thị có trọng số âm (nhưng không có chu trình âm).\nBellman-Ford(s) {\n Bước 1 (Khởi tạo): for v ∈ V: d[v] = a(s, v), truoc[v] = s; d[s] = 0\n Bước 2 (Lặp):\n  for k = 1 → n-1:\n    for v ∈ V \\ {s}:\n      for u ∈ V:\n        if d[v] > d[u] + a(u, v):\n          d[v] = d[u] + a(u, v), truoc[v] = u\n }",
    "Floyd": "Dùng cho bài toán tìm đường đi ngắn nhất giữa mọi cặp đỉnh, hoạt động được với trọng số âm (không chu trình âm).\nFloyd() {\n Bước 1 (Khởi tạo): d[i, j] = a(i, j); next[i, j] = (a[i, j] != ∞) ? j : null\n Bước 2 (Lặp):\n  for k = 1 → n:\n    for i = 1 → n:\n      for j = 1 → n:\n        if d[i, j] > d[i, k] + d[k, j]:\n          d[i, j] = d[i, k] + d[k, j]\n          next[i, j] = next[i, k]\n }",
    "Mạng ": "Mạng là đồ thị có hướng thỏa mãn:\n 1. Có duy nhất 1 điểm phát s (không có cung vào).\n 2. Có duy nhất 1 điểm thu t (không có cung ra).\n 3. Mỗi cung e = (u, v) có khả năng thông qua c_e = c(u, v) ≥ 0.",
    "Luồng mạng": "Hàm f(u, v) là một luồng nếu:\n 1. 0 ≤ f(u, v) ≤ c(u, v) (Không vượt khả năng thông qua).\n 2. Tổng luồng vào = Tổng luồng ra, với mọi đỉnh v ≠ s, t (Bảo toàn luồng).\nGiá trị luồng: val(f) = Tổng luồng đi ra từ s.",
    "Lát cắt trong mạng": "Là một phân hoạch tập đỉnh V thành X và X* sao cho s ∈ X và t ∈ X*.\nKhả năng thông qua của lát cắt: c(X, X*) = Tổng khả năng thông qua của các cung (v, w) với v ∈ X, w ∈ X*.",
    "Đường tăng luồng ": "Là một đường đi từ s đến t trong đồ thị tăng luồng Gf (đồ thị Gf được xây dựng dựa trên luồng f hiện tại và khả năng thông qua còn dư của các cạnh).",
    "Ford-Fulkerson": "Dùng để tìm luồng cực đại trong mạng.\n1. Bắt đầu với luồng f = 0.\n 2. Xây dựng đồ thị tăng luồng Gf.\n 3. Tìm một đường tăng luồng P từ s đến t trong Gf:\n  - Nếu không có: Dừng lại. Luồng f hiện tại là cực đại.\n  - Nếu có: Tăng luồng f dọc theo đường P, tạo luồng mới f', và quay lại bước 2."
   
}
